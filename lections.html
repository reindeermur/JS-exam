<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Экзамен JavaScript</title>
    <link rel="stylesheet" href="lections.css" type="text/css">
</head>
<body>
    <ol class="baseNumeration">
        <li><h3>Типы данных</h3>
            <ul class="introduce"><b>Типов данных всего 6:</b>
                <li>Числа</li>
                <li>Строки</li>
                <li>Булевы величины</li>
                <li>Неопределенные величины</li>
                <li>Объекты и массивы</li>
                <li>Функции</li>
            </ul>
            <ol type="I">
                <li>Числа
                    <ul>
                        <li>Системы счисления
                            <ul>
                                <li><b>По умолчанию установлена десятичная</b></li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Память
                            <ul>
                                <li>Отводится 64 бита под число:
                                    <ul>
                                        <li>1 бит под знак</li>
                                        <li>несколько под позици плавающей точки</li>
                                        <li>само число</li>
                                    </ul>
                                </li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Экспоненциальная запись
                            <ul>
                                <li>2.9998e8</li>
                                <i>Представится как 2.9998 * 10^8 = 299980000</i>
                            </ul>
                        </li>
                        <li>Бесконечность
                            <ul>
                                <li>Infinity</li>
                                <li>-Infinity</li>
                                <i>По умолчанию больше (меньше) любого числа в JavaScript</i>
                            </ul>
                        </li>
                        <li>NaN (Not a Number)<br>
                            <i>Образуется в результате херовых операций с числами</i>
                        </li>
                        <li>Объекты, массивы, функции будут рассмотрены дальше</li>
                    </ul>
                </li>
                <li>Строки
                    <ul>
                        <li>Могут декларироваться одинарными или двойными кавычками</li>
                        <li>Некоторые символы приходится экранировать <br><i>например <span class="code">\\</span> 
                            или <span class="code">\'</span> экранируются в <span class="code">\</span> и <span class="code">'</span> соответственно</i></li>
                        <li>Используют таблицу Unispan</li>
                        <li>Являются неизменяемыми</li>
                        <li>Методы:
                            <ul>
                                <li><span class="code">'...'.length</span>
                                     -- <i>Возвращает длину строки</i></li>
                                <li><span class="code">'...'.slice(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает новую обрезанную с 1 по 2 аргумент строку</i></li>
                                <li><span class="code">'...'.indexOf(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает true, если нашел подстроку, начиная со 2 аргумента</i></li>
                                <li><span class="code">'...'.toLowerCase()</span>
                                    -- <i>Приводит к нижнему регистру</i></li>
                                <li><span class="code">'...'.trim()</span>
                                    -- <i>Удаляет пробелы с начала и конца</i></li>
                                <li><span class="code">'...'.startsWith(...)</span>
                                    -- <i>Говорит, начинается ли строка с подстроки</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Логический тип
                    <ul>
                        <li>true</li>
                        <li>false</li>
                    </ul>
                </li>
                <li>Неопределенные типы данных
                    <ul>
                        <li>undefined</li>
                        <li>null</li>
                    </ul>
                </li>
            </ol>
        </li>
        <li><h3>Оператор typeof</h3>
            <ul>
                <li>Возвращает тип аргумента</li>
                <li>Синтаксис оператора: <span class="code">typeof x;</span></li>
                <li>Синтаксис функции: <span class="code">typeof(x);</span></li>
                <li>Работают одинаково</li>
            </ul>
        </li>
        <li><h3>parseInt</h3> Принимает 2 аргумента:
            <ul>
                <li>Строка, которую необходимо преобразовать</li>
                <li>Система счисления, к которой необходимо преобразовать</li>                
            </ul>
        </li>
        <li><h3>Number()</h3> Принимает 1 аргумент</li>
        <li><h3>parseFloat</h3> Принимает 1 аргумент</li>
        <li><h3>Переменные</h3> 2 способа декларации
            <ul>
                <li><span class="code">var</span></li>
                <li><span class="code">const и let</span></li> <i>введены в ES6</i>
            </ul>
        </li>
        <li><h3>Именование</h3>
            <ul>
                <li>Первый символ: <br> <pre><span class="code">a-z     _       $</span></pre></li>
                <li>Остальные символы: <br> <pre><span class="code">a-z     A-Z     0-9     _       $</span></pre></li>
                <li>Принятый стиль: <b>camelCase</b></li>
                <li>Запрещается использование ключевых слов в именах</li>
                <li>Если используется <span class="code">var</span>, константы именуются с большой буквы</li>
            </ul>
        </li>
        <li><h3>Комментарии</h3>
            <ul>
                <li>Блочные: <span class="code">/* ... */</span></li>
                <li>Строчные: <span class="code">// ...</span></li>
            </ul>
        </li>
        <li><h3>Операторы</h3> <b>В порядке уменьшения приоритета:</b>
            <ul>
                <li>Унарные
                    <ul>
                        <li>++</li><li>--</li><li>+</li><li>-</li><li>! (логическое отрицание)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Бинарные
                    <ul>
                        <li>*</li><li>/</li><li>%</li><hr class="operatorsPriority">
                        <li>+</li><li>-</li><li>+ (конкатенация строк)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Сравнения
                    <ul>
                        <li><</li><li><=</li><li>></li><li>>=</li>
                        <li>== (нестрогое сравнение (с приведением типов))</li>
                        <li>!=</li>
                        <li>=== (строгое сравнение (без приведения типов))</li>
                        <li>!==</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Логические
                    <ul>
                        <li>&&</li><hr class="operatorsPriority">
                        <li>||</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Присваивание
                    <ul>
                        <li>Простое</li>
                        <li>Составное</li>
                    </ul>
                </li>
                <li>Условные опреаторы
                    <ul>
                        <li><pre><span class="code">if(...) { 
        ...
} else {
        ...
}</span></pre></li>
                        <li>Тернарный условный оператор<br><span class="code">(expression) ? true-block : false-block</span></li>
                        <li>switch-case:
<pre><span class="code">switch(expression) {
        case 'value1':
                ...
                [break];
        case 'value2':
                ...
                [break];
        ...
        default:
                ...
}</span></pre>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Точка с запятой (строгий и нестрогий режимы)</h3>
            <ul>
                <li>Точка с запятой может не ставиться в нестрогом режиме, но это может привести к ошибке</li>
                <li>Для включения строгого режима в начале файла пишется: <span class="code">'use strict';</span></li>
            </ul>
        </li>
        <li><h3>Массивы</h3>
            <ul>
                <li>Спископодобный тип данных, который может хранить в себе список, содержащий значение (в том числе строки, массивы, etc)</li>
                <li>Итерирование по массиву может осуществляться циклом for или методом forEach</li>
                <li>Методы и свойства:
                    <ul>
                        <li><span class="code">[...].forEach(callback-function)</span>
                            -- <i>передается функция, которая 1 аргументом принимает текущий элемент, 2-м -- текущий индекс и делает всякие штуки</i></li>
                        <li><span class="code">[...].filter(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но возвращает true или false, согласно которым строится новый массив из не только лишь всех элементов</i></li>
                        <li><span class="code">[...].map(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но полученные значения запишутся в новый массив</i></li>
                        <li><span class="code">[...].join('...')</span>
                            -- <i>Принимает строчку и с ее помощью конкатинирует все элементы массива</i></li>
                        <li><span class="code">[...].length</span>
                            -- <i>Возвращает количество элементов в массиве</i></li>
                        <li><span class="code">[...].push(...)</span>
                            -- <i>Принимает новое значение и добавляет его в конец массива</i></li>
                        <li><span class="code">[...].pop()</span>
                            -- <i>Удаляет последний элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].sort(callback-function)</span>
                            -- <i>Сортирует массив (может принимать функцию сортировки), по умолчанию сортирует по алфавиту</i></li>
                        <li><span class="code">[...].every(callback-function)</span>
                            -- <i>Проверяет, удовлетворяют ли ВСЕ элементы массива условию</i></li>
                        <li><span class="code">[...].some(callback-function)</span>
                            -- <i>Проверяет, удовлетворяет ли ХОТЯ БЫ ОДИН элемент массива условию</i></li>
                        <li><span class="code">[...].shift(...)</span>
                            -- <i>Удаляет первый элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].unshift(...)</span>
                            -- <i>Принимает новое значение и добавляет его в начало массива</i></li>
                        <li><span class="code">[...].concat(другойМассив)</span>
                             -- <i>Объединяет массивы. <b>В результате образуется новый массив</b></i></li>
                        <li><span class="code">[...].slice</span>
                             -- <i>Работает, как и для строк, но если не передать параметры, вернет копию</i></li>
                        <li><span class="code">[...].splice(from, howMuch, '...')</span>
                             -- <i>from - откуда считаем, howMuch - сколько удаляем, последним - чем замещаем</i></li>
                        <li><b>reduce (охуевшая пизда)</b><br>
                            <span class="code">[...].reduce(callback-function, accumulator)</span>
                            <ul>
                                <li>callback-function получает 1 аргументом текущее значение аккумулятора,
                                вторым -- текущий обрабатываемый элемент в массиве
                                <br>возвращает значение, которое записывается в аккумулятор</li>
                                <li>accumulator может быть произвольного типа, в том числе и сложного</li>
                                <li>reduce можно херачить цепочками и делать вообще адовые вещи</li>
                                <li>после применения метода reduce получаем какое-то значение, которое надо куда-то записать</li>
                                <li><i>NB: если нихера не понятно -- лучше посмотреть 
                                    <a href="https://www.coursera.org/learn/javascript-osnovy-i-funktsii/lecture/iZTEP/mietod-massiva-reduce">
                                    лекцию</a> или почитать в учебнике</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Функции для работы с массивом можно вызывать друг за другом в цепочке, образуя <b><q>цепочку вызовов</q></b></li>
            </ul>
        </li>
        <li><h3>Объекты</h3>
            <ul>
                <li>Список, состоящий из пар ключ(свойство)-значение</li>
                <li>Ключ может быть строкой или числом (преобразуется к строке)</li>
                <li>Значение может быть произвольного типа</li>
                <li>Создание:
                    <pre><span class="code">let obj = {
        author: 'Petya',
        countRow: 18,
        haveSubscribe: true,
        childAuthor: {
                name: 'Lesha',
                age: 5
        }
}</span></pre>
                </li>
                <li>Добавление свойства: <span class="code">объект.свойство = 'ето новое свойство типа строка';</span></li>
                <li>Добавление метода или свойства:
                    <pre class="expand2"><span class="code">Object.defineProperty(объект, 'toString', {         /* принимает объект, 
название нового свойства и объект конфигурирования, 
описывающий параметры свойства или метода */
        value: function() {     // м.б. примитив или функция, во втором случае -- это метод, в первом -- свойство
                return 'хаю-хай'
        },
        writable: true,         // редактируемое      
        enumerable: false,      // перечисляемое (не возвращается при запросе Object.keys(...))
        configurable: true      // редактируемое и удаляемое
        // последние 3 по умолчанию <code>false</code>
});</span></pre>
                </li>
                <li>Также существует метод <span class="code">defineProperties</span>, позволяющий декларировать сразу несколько свойств объекта</li>
                <li>Метод <span class="code">Object.getOwnPropertyDesctiptor(объект, 'свойство')</span> позволяет получить данные об объекте конфигурирования свойства объекта</li>
                <li>Удаление свойства: <span class="code">delete объект.свойство;</span> -- <i>возвращает true или false</i></li>
                <li>Обращение:
                    <ul>
                        <li>Точечная нотация</li>
                        -- <span class="code">объект.свойство</span>
                        <li>Через [...] <i>(в скобках можно передать выражение)</i></li>
                        -- <span class="code">объект['свой' + 'ство']</span>
                    </ul>
                </li>
                <li>Итерирование: <span class="code">var ключ = Object.keys(объект);</span>
                    <ul>
                        <li>Возвращает массив строк (ключей) <i>NB: (это будут перечисляемые свойства)</i></li>
                        <li><i>Существует также Object.values(obj), но технология является экспериментальной</i></li>
                    </ul>
                </li>
                <li>Наличие свойства: <span class="code">объект.hasOwnProperty('свойство');</span>
                    <ul>
                        <li>Возвращает true или false</li>
                        <li>Кавычки писос как важны</li>
                    </ul>
                </li>
                <li><b>Геттеры и сеттеры</b> -- альтернативные способы декларации свойств и методов объекта
                    <ul>
                        <li>специальные методы объекта, которые вызываются при обращении к свойству на чтение и на запись</li>
                        <li>удобно при работе с динамическими свойствами, регулируя правила работы с ними и ограничения</li>
                        <li><span class="code">Object.defineProperty(объект, 'свойство', {
get: function() {
        return this.другоеСвойство;
},
set: function(value) {
        this.другоеСвойство = parseInt(value) || 0;
}
});</span></pre></li>
                        <li>Геттеры срабатывает при обращении на чтение, например <span class="code">объект.свойство</span><br>
                        Сеттер срабатывает при обращении на запись, как то: <span class="code">объект.свойство = 'cerf'</span></li>
                    </ul>
                </li>
                <li><b>Заморозка</b>
                    <ul>
                        <li>Задается при помощи <span class="code">Object.freeze(объект)</span></li>
                        <li>Убирает writable, configurable, но оставляет enumerable: true</li>
                        <li><span class="code">Object.isFrozen(объект)</span> возвращает true, если объект заморожен</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Объект Date</h3>
            <ul>
                <li><span class="code">new Date();</span> создает объект с текущей датой в системном часовом поясе</li>
                <li><span class="code">new Date('строка');</span> попытается преобразовать строку к дате</li>
                <li><span class="code">new Date(число);</span> преобразует как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (UNIX Timestamp)</li>
                <li><span class="code">new Date(число, число[, число, ...]);</span> год, месяц(начиная с 0) [, день, часы, минуты, секуды и мс</li>
                <li><span class="code">(new Date(что-то)).valueOf();</span> вернет UNIX Timestamp (секунды) от переданного</li>
                <li><span class="code">Date.now();</span> вернет текущий UNIX Timestamp (секунды)</li>
                <li><i>Старый, работает хуево. Образца Java 1995. Рекомендуется ознакомиться с документацией.</i></li>
            </ul>
        </li>
        <li><h3><b>Объект Math</b> -- библиотека мат. функций и констант</h3>
            <ul>
                <li><span class="code">Math.random();</span> возвращает случайное число от 0 до 1</li>
                <li><span class="code">Math.min(2 и более значений);</span> выбирает минимальное</li>
                <li><span class="code">Math.max(2 и более значений);</span> выбирает максимальное</li>
                <li>Округление
                    <ul>
                        <li><span class="code">Math.round(число);</span> округляет арифметически</li>
                        <li><span class="code">Math.floor(число);</span> округляет вниз</li>
                        <li><span class="code">Math.ceil(число);</span> округляет вверх</li>
                    </ul>
                </li>
                <li><span class="code">Math.log(число);</span> вернет натуральный логарифм</li>
                <li><span class="code">Math.pow(числоA, числоB);</span> вернет a<sup>b</sup></li>
                <li>Есть еще дохера, типа синус, тангенс, etc</li>
            </ul>
        </li>
        <li><h3>Функции</h3>
            <ul>
                <li>Именованный блок кода</li>
                <li>Повышает повторное использование кода</li>
                <li>Может иметь или не иметь входные параметры</li>
                <li>Может возвращать или не возвращать значение <i>NB: во втором случае неявно возвращает <code>undefined</code></i></li>
                <li>Являются объектами высшего порядка: <b><i><q>Могут быть переданы в другие функции в качестве аргумента, 
                    а также могут иметь личные свойства, как и другие объекты</q></i></b></li>
                <li>Входные параметры передаются по значению или по ссылке:
                    <ul>
                        <li>По значению передаются примитивы: число, строка, etc
                        <br><i>В этом случае все, что происходило с ним внутри функции, остается внутри функции (копируется)</i></li>
                        <li>По ссылке передаются сложные типы данных: массив, объект, функция, etc
                        <br><i>В этом случае все изменения с этими данными изменяют передаваемый параметр, работая непосредственно с ним</i></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Обработка исключений</h3>
            <ul>
                <li>Применяется для того, чтобы не обрабатывать все возможные варианты 
                    всех возможных значений, а просто кинуть ошибку, если данные хуевые</li>
                <li><span class="code">throw new TypeError('Vse huevo');</span></li>
                <li>Могут быть разные ошибки на все случаи жизни</li>
                <li>Как правило на практике используется конструкция try ... catch</li>
                <li><pre class="expand"><span class="code">try {
        /* всякие штуки, которые могут вызвать исключение */
} catch(e) {
        /* обработка исключение, с помощью instanceof NAMEERROR */
        /* e -- это объект исключения, содержит поля name, message, stack */
}</span></pre></li>
            </ul>
        </li>
        <li><h3>Сравнение разных типов данных</h3>
            <ul>
                <li><b>Объект и строка:</b>
                    <ul>
                        <li>Сначала к левому и правому операндам применяется внутренний метод isPrimitive(...), 
                            отвечающий, является ли он примитивным типом</li>
                        <li>Проверяет, существует ли у левого операнда функция .toString: <br>
                        <span class="code">typeof операнд.toString === 'function'; // true или false</span></li>
                        <li>Если функция есть, то она применяется и сравнивается результат ее работы со строкой</li>
                    </ul>
                </li>
                <li>Сравнение двух сложных типов данных почти всегда вернет false, 
                    кроме случая, когда оба объекта ссылаются на один и тот же объект в памяти</li>
                <li>Существует строгое и нестрогое сравнение (=== и ==). Второе допускает неявное
                    преобразование левого операнда к типу правого<i>NB: рекомендуется всегда юзать строгое</i></li>
                <li>Приведение объекта к строке:
                    <ul>
                        <li><span class="code">String(объект);</span></li>
                        <li><span class="code">'' + объект;</span></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Регулярные выражения</h3>
            <ul>
                <li>Записывается внутри /.../</li>
                <li>Существуют флаги, пишущиеся после /.../(СЮДА), например, <span class="code">g</span> (глобальное сопоставление) или <span class="code">i</span> (игнор регистра)</li>
                <li>Две функции для работы с регвырами:
                    <ul>
                        <li><span class="code">регвыр.test(что-то)</span> проверяет содержание регвыра в строке</li>
                        <li><span class="code">регвыр.test(что-то)</span> проверяет содержание регвыра в строке</li>
                    </ul>
                </li>
                <li>Имеют PCRE-совместимый синтаксис (Perl Compatible Regular Expression)</li>
            </ul>
        </li>
        <li><h3></h3>
            <ul>
                <li></li>
            </ul>
        </li>
    </ol>
</body>
</html>